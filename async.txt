        Асинхронное программирование – производительность async: понять расходы на async и await

Асинхронное программирование долгое время было царством самых опытных разработчиков с тягой к мазохизму – тех, кто имел достаточно свободного
времени, склонность и психические способности размышлять об обратных вызовах (callback) из обратных вызовов в нелинейном потоке выполнения.
С появлением Microsoft .NET Framework 4.5, C# и Visual Basic принесли асинхронность всем нам, так что простые смертные теперь могут писать
асинхронные методы почти так же легко, как синхронные. Обратные вызовы больше не нужны. Больше не нужна явная передача (marshaling) кода из
одного контекста синхронизации в другой. Больше не нужно беспокоиться как двигаются результаты выполнения или исключения. Нет необходимости
в трюках, которые искажают средства языков программирования для удобства разработки асинхронного кода. Короче говоря, больше нет мороки и
головной боли.
        Когда не нужно использовать Async
.NET Framework пытается сгенерировать эффективные реализации для асинхронных методов, применяя различные способы оптимизации. Тем не менее,
разработчики, основываясь на своём опыте, часто применяют свои методы оптимизации, которые могут быть рискованы и нецелесообразны для
автоматизации компилятором и средой выполнения, так как они пытаются использовать универсальные подходы. Если не забывать об этом, отказ от
использования async методов приносит пользу в ряде специфических случаев, в особенности, это касается методов в библиотеках, которые могут
быть использованы с более тонкими настройками. Обычно это происходит, когда точно известно, что метод может быть выполнен синхронно, так
как данные, от которых он зависит, уже готовы.
        Асинхронность и производительность
Асинхронные методы являются мощным средством разработки, позволяющим легче писать масштабируемые библиотеки и приложения с малым временем отклика.
Важно помнить, что асинхронность не даёт оптимизации производительности для отдельной операции. Превращение синхронной операции в асинхронную
всегда приведёт к ухудшению производительности этой операции, поскольку помимо исполнения всей логики синхронной операции добавляются
дополнительные ограничения и аспекты. Причиной, по которой вы можете использовать асинхронность, является производительность в комплексе
приложения: как ваша система работает в целом, когда всё выполняется в асинхронном режиме, так вы можете совмещать операции ввода/вывода
и достичь более эффективной загрузки системы при использовании важных ресурсов, только когда они реально нужны для выполнения. Реализация
асинхронных методов в .NET Framework хорошо оптимизирована и часто в конечном итоге обеспечивает производительность не хуже правильно
написанного кода, использующего устоявшиеся шаблоны и гораздо более объёмного. В любой момент, когда вам понадобится применить асинхронность
в .NET Framework, асинхронные методы будут хорошим выбором. Но вам, как разработчику, необходимо знать что для вас делает Framework, чтобы
быть уверенным, что окончательный результат хорош настолько, насколько возможно.

        Асинхронное программирование от моего взгляда
В синхронном коде каждая операция ожидает окончания предыдущей. Поэтому вся программа может зависнуть, если одна из команд выполняется очень долго.
Асинхронный код убирает блокирующую операцию из основного потока программы, так что она продолжает выполняться, но где-то в другом месте, а
обработчик может идти дальше. Проще говоря, главный "процесс" ставит задачу и передает ее другому независимому "процессу".
Асинхронное программирование успешно решает множество задач. Одна из самых важных – доступность интерфейса пользователя.
Возьмем для примера приложение, которое подбирает фильм по указанным критериям. После того как пользователь выбрал параметры, программа
отправляет запрос на сервер. А там происходит подбор подходящих картин. Обработка может длиться довольно долго. Если приложение работает синхронно,
то пользователь не сможет взаимодействовать со страницей, пока не придет результат. Он не сможет даже скроллить!


ссылка: https://habr.com/ru/post/458332/